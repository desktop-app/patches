diff --git a/tools/generate_wrap_init.pl.in b/tools/generate_wrap_init.pl.in
index f49fe2f2..7a40db96 100644
--- a/tools/generate_wrap_init.pl.in
+++ b/tools/generate_wrap_init.pl.in
@@ -206,6 +206,7 @@ print << "EOF";
 // Generated by generate_wrap_init.pl -- DO NOT MODIFY!
 
 #define GLIBMM_INCLUDED_FROM_WRAP_INIT_CC
+#include <dlfcn.h>
 #include <glibmm.h>
 
 // Disable the 'const' function attribute of the get_type() functions.
@@ -360,8 +361,8 @@ foreach my $sub_namespace (sort keys %extra_namespaces)
       my ($cppname, $basename, @extra_namespace) = @{$i};
       if (@extra_namespace > 0 && $sub_namespace eq join("::", @extra_namespace))
       {
-        $message .= "  Glib::Error::register_domain(${basename}_quark(), &" .
-                    "${sub_namespace}::${cppname}::throw_func);\n";
+        $message .= "  if (const auto func = (decltype(&${basename}_quark)) dlsym(RTLD_DEFAULT, \"${basename}_quark\"))\n" .
+                    "    Glib::Error::register_domain(func(), &${sub_namespace}::${cppname}::throw_func);\n";
       }
     }
     print_with_guards($filename_header, $message) if $message;
@@ -386,8 +387,8 @@ foreach my $filename_header (sort keys %exceptions)
     my ($cppname, $basename, @extra_namespace) = @{$i};
     if (@extra_namespace == 0)
     {
-      $message .= "  Glib::Error::register_domain(${basename}_quark(), &" .
-                  "${cppname}::throw_func);\n";
+      $message .= "  if (const auto func = (decltype(&${basename}_quark)) dlsym(RTLD_DEFAULT, \"${basename}_quark\"))\n" .
+                  "    Glib::Error::register_domain(func(), &${cppname}::throw_func);\n";
     }
   }
   print_with_guards($filename_header, $message) if $message;
@@ -418,8 +419,8 @@ foreach my $filename_header (sort keys %objects)
   {
     my ($cppname, $basename, @extra_namespace) = @{$i};
     my $qualified_cppname = join("::", (@extra_namespace, $cppname));
-    $message .= "  Glib::wrap_register(${basename}_get_type(), &" .
-                "${qualified_cppname}_Class::wrap_new);\n";
+    $message .= "  if (const auto func = (decltype(&${basename}_get_type)) dlsym(RTLD_DEFAULT, \"${basename}_get_type\"))\n" .
+                "    Glib::wrap_register(func(), &${qualified_cppname}_Class::wrap_new);\n";
   }
   print_with_guards($filename_header, $message);
 }
diff --git a/tools/m4/base.m4 b/tools/m4/base.m4
index 45354752..a3dae03f 100644
--- a/tools/m4/base.m4
+++ b/tools/m4/base.m4
@@ -134,8 +134,17 @@ dnl also pre-pending an '_' to the pairs.  Finally, it converts all characters
 dnl to lowercase (with the translit), removing the first '_' (with substr) and
 dnl appending _get_type().  This works with regular types like GtkWidget, but
 dnl also multi-cap types like GdkGCFooBar or GdkFOOBar.
+
+define(`_GET_TYPE_FUNC_NAME',`dnl
+m4_translit(m4_substr(m4_patsubst(m4_patsubst(`$1',`[A-Z][A-Z]+',`_\&'),`[A-Z][a-z]',`_\&'),1),`[A-Z]',`[a-z]')_get_type`'dnl
+')
+
 define(`_GET_TYPE_FUNC',`dnl
-m4_translit(m4_substr(m4_patsubst(m4_patsubst(`$1',`[A-Z][A-Z]+',`_\&'),`[A-Z][a-z]',`_\&'),1),`[A-Z]',`[a-z]')_get_type()`'dnl
+[] {
+  if (const auto func = (decltype(&_GET_TYPE_FUNC_NAME($1))) dlsym(RTLD_DEFAULT, "_GET_TYPE_FUNC_NAME($1)"))
+    return func();
+  return GType();
+}()
 ')
 
 dnl Define a new diversion
@@ -337,6 +346,7 @@ _IMPORT(SECTION_CC_PRE_INCLUDES)
 
 _DEPRECATE_IFDEF_CLASS_CONFIG_START
 
+#include <dlfcn.h>
 #include <glibmm.h>
 
 #include <__MODULE__/__FILE__.h>
diff --git a/tools/m4/class_interface.m4 b/tools/m4/class_interface.m4
index 3c0b93ef..6be342a1 100644
--- a/tools/m4/class_interface.m4
+++ b/tools/m4/class_interface.m4
@@ -84,7 +84,8 @@ const Glib::Interface_Class& __CPPNAME__`'_Class::init()
     class_init_func_ = &__CPPNAME__`'_Class::iface_init_function;
 
     // We can not derive from another interface, and it is not necessary anyway.
-    gtype_ = _LOWER(__CCAST__)_get_type();
+    if (const auto func = (decltype(&_LOWER(__CCAST__)_get_type)) dlsym(RTLD_DEFAULT, "_LOWER(__CCAST__)_get_type"))
+      gtype_ = func();
   }
 
   return *this;
diff --git a/tools/m4/class_shared.m4 b/tools/m4/class_shared.m4
index 68804128..2d84d1a4 100644
--- a/tools/m4/class_shared.m4
+++ b/tools/m4/class_shared.m4
@@ -164,7 +164,8 @@ ifdef(`__BOOL_DO_NOT_DERIVE_GTYPE__',`dnl
     //CppClassParent::CppObjectType::get_type();
 
     // Create the wrapper type, with the same class/instance size as the base type.
-    register_derived_type(_LOWER(__CCAST__)_get_type());
+    if (const auto func = (decltype(&_LOWER(__CCAST__)_get_type)) dlsym(RTLD_DEFAULT, "_LOWER(__CCAST__)_get_type"))
+      register_derived_type(func());
 
     // Add derived versions of interfaces, if the C type implements any interfaces:
 _IMPORT(SECTION_CC_IMPLEMENTS_INTERFACES)
@@ -191,7 +192,8 @@ ifdef(`__BOOL_DO_NOT_DERIVE_GTYPE__',`dnl
     //CppClassParent::CppObjectType::get_type();
 
     // Create the wrapper type, with the same class/instance size as the base type.
-    register_derived_type(_LOWER(__CCAST__)_get_type(), module);
+    if (const auto func = (decltype(&_LOWER(__CCAST__)_get_type)) dlsym(RTLD_DEFAULT, "_LOWER(__CCAST__)_get_type"))
+      register_derived_type(func(), module);
 
     // Add derived versions of interfaces, if the C type implements any interfaces:
 _IMPORT(SECTION_CC_IMPLEMENTS_INTERFACES)
@@ -244,7 +246,9 @@ GType __CPPNAME__::get_type(GTypeModule* module)
 
 GType __CPPNAME__::get_base_type()
 {
-  return _LOWER(__CCAST__)_get_type();
+  if (const auto func = (decltype(&_LOWER(__CCAST__)_get_type)) dlsym(RTLD_DEFAULT, "_LOWER(__CCAST__)_get_type"))
+    return func();
+  return GType();
 }
 
 _IMPORT(SECTION_CC)
